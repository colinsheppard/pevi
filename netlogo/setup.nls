;;;;;;;;;;;;;;;;;;;;;;;
;; READ PARAMETER FILE
;;;;;;;;;;;;;;;;;;;;;;;
to read-parameter-file
  ;print "read-parameter-file"
  set stranded-delay-threshold 3
  ifelse (file-exists? parameter-file) [ 
    file-close
    file-open parameter-file
    while [not file-at-end?][
      let param-name file-read
      ifelse param-name = "n-tazs" [ set n-tazs file-read ][  ; TODO, infer this from the od input file
      ifelse param-name = "n-charger-types" [ set n-charger-types file-read ][  ; TODO, infer this from the od input file
      ifelse param-name = "charge-safety-factor" [ set charge-safety-factor file-read ][
      ifelse param-name = "charger-search-distance" [ set charger-search-distance file-read ][
      ifelse param-name = "wait-time-mean" [ set wait-time-mean file-read ][
      ifelse param-name = "time-opportunity-cost" [ set time-opportunity-cost file-read ][
      ifelse param-name = "willing-to-roam-time-threshold" [ set willing-to-roam-time-threshold file-read ][
      ifelse param-name = "frac-phev" [ set frac-phev file-read ][
      ifelse param-name = "electric-fuel-consumption-sd" [ set electric-fuel-consumption-sd file-read ][
      ifelse param-name = "electric-fuel-consumption-range" [ set electric-fuel-consumption-range file-read ][
      ifelse param-name = "charger-input-file" [ set charger-input-file word model-directory file-read ][
      ifelse param-name = "charger-type-input-file" [ set charger-type-input-file word model-directory file-read ][
      ifelse param-name = "driver-input-file" [ set driver-input-file word model-directory file-read ][
      ifelse param-name = "od-input-file" [ set od-input-file word model-directory file-read ][
      ifelse param-name = "vehicle-type-input-file" [ set vehicle-type-input-file word model-directory file-read ][
      ifelse param-name = "outputs-directory" [ set outputs-directory word model-directory file-read ][
      ifelse param-name = "probability-of-unneeded-charge" [ set probability-of-unneeded-charge file-read ][
      ifelse param-name = "stranded-delay-threshold" [ set stranded-delay-threshold file-read ][  
      ]]]]]]]]]]]]]]]]]]
    ]
    file-close
  ][ 
    error (word "Input file '" parameter-file "' not found!") 
  ]
end

;;;;;;;;;;;;;;;;;;;;
;; SETUP OD DATA
;;;;;;;;;;;;;;;;;;;;
to setup-od-data
  ;print "setup-od-data"
  ; Reads in main driver input file: Origin, destination, # of trips, distance, time
  set od-from   n-values (n-tazs * n-tazs) [0] 
  set od-to     n-values (n-tazs * n-tazs) [0] 
  set od-dist   n-values (n-tazs * n-tazs) [0] 
  set od-time   n-values (n-tazs * n-tazs) [0] 
  set od-enroute n-values (n-tazs * n-tazs) [n-values (0) [0]] 
  set od-performance   n-values (n-tazs * n-tazs) [0]
  
  ifelse (file-exists? od-input-file) [
    file-close
    file-open od-input-file
    foreach n-values (n-tazs * n-tazs) [?] [
     set od-from   replace-item ? od-from file-read 
     set od-to     replace-item ? od-to   file-read 
     set od-dist   replace-item ? od-dist file-read 
     set od-time   replace-item ? od-time file-read
     set od-enroute replace-item ? od-enroute split file-read ","
     set od-performance replace-item ? od-performance file-read
    ]
    file-close
  ][ 
    error (word "Input file '" od-input-file "' not found!") 
  ]
end 

;;;;;;;;;;;;;;;;;;;;
;; SPLIT
;; Helper function written by jimlyons37: http://groups.yahoo.com/group/netlogo-users/message/6490
;; Adapted by Colin to allow empty string as argument and assumes elements are numbers, not strings
;;;;;;;;;;;;;;;;;;;;
to-report split [ #string #sep ] ; #sep must be non-empty string
  let result [] ; return value
  let w length #sep
  if length #string = 0 [ report result ]
  loop[ ; exit when done
    let next-pos position #sep #string
    if not is-number? next-pos [ report reverse (fput read-from-string #string result) ]
    set result fput read-from-string (substring #string 0 next-pos) result
    set #string substring #string (next-pos + w) (length #string)
  ]
end

;;;;;;;;;;;;;;;;;;;;
;; SETUP TAZS
;;;;;;;;;;;;;;;;;;;;
to setup-tazs
  ;print "setup-tazs"
  let #prev-taz-id 0
  create-tazs n-tazs
  ask tazs [
    set shape "star"
    set color yellow
    set size 0.5
    set n-levels n-values 4 [-99] 
    set chargers-by-type n-values n-charger-types [0]
  ]
  ifelse (file-exists? charger-input-file) [
    file-close
    file-open charger-input-file
    foreach sort tazs [  ; we want the who value to match the id, so we sort them, this assumes the text file has sequential ids starting from 1
      ask ? [
        set id file-read
        if id != #prev-taz-id + 1 [ error (word "In setup-tazs, was expecting to read taz #" (#prev-taz-id + 1) " from file but found #" id " instead.") ]
        set #prev-taz-id id
        foreach [0 1 2 3] [
          set n-levels replace-item ? n-levels file-read ; sets the number of level X chargers in each TAZ
        ]
        set neighbor-tazs n-values 0 [0]
        foreach n-values n-tazs [? + 1] [
          if not (? = id) and (distance-from-to id ? <= charger-search-distance) [
            set neighbor-tazs fput taz ? neighbor-tazs
          ]
        ]
      ]
    ]
  ]
  [ error (word "Input file '" charger-input-file "' not found!")]
   
end ;setup-tazs

;;;;;;;;;;;;;;;;;;;;;;;
;; CONVERT ENROUTE IDS
;;;;;;;;;;;;;;;;;;;;;;;
to convert-enroute-ids
  foreach n-values length od-enroute [?] [
    let old-enroute-list item ? od-enroute
    foreach n-values length old-enroute-list [?] [
      set old-enroute-list replace-item ? old-enroute-list (taz item ? old-enroute-list)
    ]
    set od-enroute replace-item ? od-enroute old-enroute-list
  ]
end

;;;;;;;;;;;;;;;;;;;;
;; SETUP CHARGER-TYPES
;;;;;;;;;;;;;;;;;;;;
to setup-charger-types
  ;print "setup-charger-types"
  
  ifelse (file-exists? charger-type-input-file) [
    file-close
    file-open charger-type-input-file
    while [file-at-end? = false] [
      create-charger-types 1 [
        set level file-read
        set charge-rate file-read
        set energy-price file-read
        set installed-cost file-read
      ]
    ]
    file-close
  ][ 
    error (word "Input file '" charger-type-input-file "' not found!") 
  ]
end 

;;;;;;;;;;;;;;;;;;;;
;; SETUP CHARGERS
;;;;;;;;;;;;;;;;;;;;
to setup-chargers
  ;print "setup-chargers"
  ; The charger level, location, and quantity of chargers was read in during setup-tazs.
  ; Now chargers of each level are created at the appropriate taz.
  ; Charger-rate is currently a separate state variable from charger level. We may want to combine the two later, if
  ; we do not use "charger level" for anything else.

  ; At each taz,  chargers equal to "taz-chargers"are created.
  foreach sort tazs [
    let #this-taz ?
    create-chargers [item 0 n-levels] of #this-taz [  ; The location of each charger created is then set as the current TAZ location
      set this-charger-type one-of charger-types with [level = 0]
      set location ?
    ]
    create-chargers [item 1 n-levels] of #this-taz [  ; The location of each charger created is then set as the current TAZ location
      set this-charger-type one-of charger-types with [level = 1]
      set location ?
    ]
    create-chargers [item 2 n-levels] of #this-taz [  ; The location of each charger created is then set as the current TAZ location
      set this-charger-type one-of charger-types with [level = 2]
      set location ?
    ]
    create-chargers [item 3 n-levels] of #this-taz [  ; The location of each charger created is then set as the current TAZ location
      set this-charger-type one-of charger-types with [level = 3]
      set location ?
    ]
    foreach n-values n-charger-types [?] [
      ask #this-taz [
        set chargers-by-type replace-item ? chargers-by-type chargers with [([level] of this-charger-type = ?) and (location = myself)]
      ]
    ]
  ]  
  ask chargers [
    set shape "Circle 2"
    set color red
    set size 1
    set current-driver nobody
    let #level [level] of this-charger-type
    set energy-delivered 0
  ]
end ;setup-chargers


;;;;;;;;;;;;;;;;;;;;
;; SETUP DRIVERS
;;;;;;;;;;;;;;;;;;;;
to setup-drivers
  ;print "setup-drivers"

  setup-vehicle-types
  setup-itinerary

  ; assing driver vehicles to a vehicle type
  ; first deal with drivers that must belong to certain vehicle types due to lengthy trips in their itinerary
  let #bev-types vehicle-types with [is-bev?]
  let #phev-types sort vehicle-types with [not is-bev?]
  let #used-bev-types n-values 0 [?]
  while [count #bev-types > 0][
    ask max-one-of #bev-types [ battery-capacity / electric-fuel-consumption ][     
      ; find the drivers that can't make their longest trip using the current bev type
      let #impossible-drivers drivers with [
        this-vehicle-type = nobody and 
        (
          max-trip-distance * charge-safety-factor > [battery-capacity] of myself / [electric-fuel-consumption] of myself or
          journey-distance * charge-safety-factor > (min(sentence (max-dwell-time * 6.6 / charge-safety-factor) [battery-capacity] of myself) + [battery-capacity] of myself) / [electric-fuel-consumption] of myself
        )
      ]
      ;show (word (count #impossible-drivers) " needing more range")
      
      ; find the other vehicle types that can be assigned to this driver (must check whether their num-drivers is over quota yet)
      let #available-types n-values 0 [?]
      foreach (sentence #phev-types #used-bev-types) [
        if [num-vehicles] of ? / count drivers < [frac-of-pevs] of ? [
           set #available-types lput ? #available-types
        ] 
      ]
      ;show (word "available types: " #available-types)
      
      ; now do the assignmnets
      ask #impossible-drivers [
        if length #available-types = 0 [ error "There are too many drivers with trips longer than the range of the BEVs types provided and not enough longer range BEVs and/or PHEVs to acommodate them" ]
        set this-vehicle-type one-of #available-types
        set type-assignment-code 1
        ask this-vehicle-type [ set num-vehicles num-vehicles + 1 ]
        if [num-vehicles] of this-vehicle-type / count drivers >= [frac-of-pevs] of this-vehicle-type [
          set #available-types remove this-vehicle-type #available-types
        ]
      ]
      set #bev-types #bev-types with [self != myself]
      set #used-bev-types lput self #used-bev-types
    ]
  ]
  
  ; second assign the remaining vehicle types to drivers according to the remainder
  let #unassinged-drivers sort drivers with [this-vehicle-type = nobody]
  ;print length #unassinged-drivers / count drivers 
  let #available-types vehicle-types with [(frac-of-pevs * count drivers) - num-vehicles > 0 ]
  ask #available-types [
    while[(frac-of-pevs * count drivers) - num-vehicles > 0 and length #unassinged-drivers > 0 ][
      ask one-of #unassinged-drivers [
        set this-vehicle-type myself
        set type-assignment-code 2
        set #unassinged-drivers remove self #unassinged-drivers 
      ]
      set num-vehicles num-vehicles + 1
    ]
  ]
  ; if drivers remaing unassigned, give them a PHEV
  ask drivers with [this-vehicle-type = nobody] [
    set this-vehicle-type one-of vehicle-types with [not is-bev?]
    set type-assignment-code 3
  ]
  
  ; finally initialize driver state variables
  ask drivers [
    ;plug-in-at-home ;; let's assume for now that the vehicles are self-programmed to START their home charging event 
                    ;; at midnight (0 ticks), and that the SOC at the beginning of the charge event
                    ;; is ~gauss(mu=.5,sigma=.2)
    ;..
    set current-itin-row -1
    update-itinerary ;; this gives each driver their first itin event of the day -- not yet scheduled
    ;..                 sets current-taz

    set shape "car"
    set color green
    set size 2
    
    set is-bev? [is-bev?] of this-vehicle-type
    set battery-capacity [battery-capacity] of this-vehicle-type
    set hybrid-fuel-consumption [hybrid-fuel-consumption] of this-vehicle-type

    let electric-fuel-consumption-mean [electric-fuel-consumption] of this-vehicle-type
    set electric-fuel-consumption random-normal electric-fuel-consumption-mean electric-fuel-consumption-sd
    while [abs (electric-fuel-consumption - electric-fuel-consumption-mean) > electric-fuel-consumption-range / 2][
      set electric-fuel-consumption random-normal electric-fuel-consumption-mean electric-fuel-consumption-sd
    ]

    set state "not-charging"
    set current-charger nobody
    set energy-used 0
    set energy-received 0
    set expenses 0
    set miles-driven 0
    set num-denials 0
  
    set itin-complete? false

    ifelse current-taz = home-taz [  ;; at home, track these vehicles for V2G
      ifelse is-bev? [
        let rand-draw random-normal 0.5 0.2
        ifelse rand-draw > 1 [
         set state-of-charge 1 
         ][
           ifelse rand-draw < 0 [
             set state-of-charge 0 
             ][
           set state-of-charge rand-draw
           ]
         ] 
        ][
        let rand-draw random-normal 0.4 0.4 ;; this is just a place-holder for now
        ifelse rand-draw > 1 [
          set state-of-charge 1 
          ][
            ifelse rand-draw < 0 [
              set state-of-charge 0 
              ][
            set state-of-charge rand-draw
            ]
          ]
        ]
      set next-home-log 0
      home-V2G-scheduler
    ][   ;; not at home -- do not track for V2G.  Schedule first departure.
      ifelse is-bev? [
        let rand-draw random-float 1
        ifelse rand-draw < 0.63 [
          set state-of-charge 0.9 + random-float 0.1
        ][
        ifelse rand-draw < 0.68 [ 
          set state-of-charge 0.8 + random-float 0.1
        ][
        ifelse rand-draw < 0.94 [ 
          set state-of-charge 0.7 + random-float 0.1
        ][
        ifelse rand-draw < 0.97 [ 
          set state-of-charge 0.6 + random-float 0.1
        ][
        ifelse rand-draw < 0.99 [ 
          set state-of-charge 0.5 + random-float 0.1
        ][
        ifelse rand-draw < 0.995 [ 
          set state-of-charge 0.4 + random-float 0.1
        ][
        set state-of-charge 0.3 + random-float 0.1
        ]]]]]]][
      set state-of-charge 1
        ]
      itinerary-event-scheduler
    ]
  ]
end ;setup-drivers

;;;;;;;;;;;;;;;;;;;;
;; SETUP VEHICLE TYPES
;;;;;;;;;;;;;;;;;;;;
to setup-vehicle-types
  ;print "setup-vehicle-types"
  
  ifelse (file-exists? vehicle-type-input-file) [
    file-close
    file-open vehicle-type-input-file
    let #cumul-frac-pevs 0
    while [file-at-end? = false] [
      create-vehicle-types 1 [
        set name file-read
        set electric-fuel-consumption file-read
        set hybrid-fuel-consumption file-read
        set battery-capacity file-read
        set frac-of-pevs file-read
        set #cumul-frac-pevs #cumul-frac-pevs + frac-of-pevs
        set is-bev? (hybrid-fuel-consumption <= 0)
        set num-vehicles 0
      ]
    ]
    file-close
    if #cumul-frac-pevs != 1 [
       error (word "Vehicle type fractions do not sum to 1.")
    ]
  ][ 
    error (word "Input file '" vehicle-type-input-file "' not found!") 
  ]
end 

;;;;;;;;;;;;;;;;;;;;
;; SETUP INTINERARY
;;;;;;;;;;;;;;;;;;;;
to setup-itinerary
  ;print "setup-itinerary"
  ifelse (file-exists? driver-input-file) [
    file-close
    file-open driver-input-file
   
    let this-itin true
    let next-driver file-read
    let this-driver 0
    while [file-at-end? = false] [
      set this-driver next-driver
      create-drivers 1 [
        set id this-driver
        set itin-from n-values 1 [file-read]
        set itin-to n-values 1 [file-read]  
        set itin-depart n-values 1 [file-read]
        set home-taz taz file-read
        let itin-row 0
        set journey-distance 0
        set max-trip-distance (distance-from-to item itin-row itin-to item itin-row itin-from)
        set max-dwell-time 0
        set this-vehicle-type nobody
        if file-at-end? = false [
          set next-driver file-read
          set this-itin true
          while [next-driver = this-driver] [  
            set itin-from  lput file-read itin-from
            set itin-to  lput file-read itin-to
            set itin-depart lput file-read itin-depart
            set itin-row itin-row + 1
            let #this-trip-distance (distance-from-to item itin-row itin-to item itin-row itin-from)
            set journey-distance (journey-distance + #this-trip-distance)
            if max-trip-distance < #this-trip-distance [
              set max-trip-distance #this-trip-distance
            ]
            if max-dwell-time < (item itin-row itin-depart - ((item (itin-row - 1) itin-depart) + (item (od-index item itin-row itin-to item itin-row itin-from) od-time))) [
              set max-dwell-time (item itin-row itin-depart - ((item (itin-row - 1) itin-depart) + (item (od-index item itin-row itin-to item itin-row itin-from) od-time)))
            ]
            if not (home-taz = taz file-read) [ error (word "Inconsistent home taz specified for driver " id ) ]
            ifelse file-at-end? [ set next-driver -1][ set next-driver file-read ]
          ] ; end while this-itin
        ]
        set itin-change-flag n-values length itin-depart [0]
        set itin-delay-amount n-values length itin-depart [0]
      ] ; end create-drivers
    ] ; end while file-at-end
  ] ; end ifelse
  [ error (word "Input file '" driver-input-file "' not found!") ]
  file-close
end ;setup-itinerary


;;;;;;;;;;;;;;;;;;;;
;; LOG DATA
;;;;;;;;;;;;;;;;;;;;
to log-data [logfile data-list]
  if (logfile = "wait-time" and log-wait-time) or
     (logfile = "charging" and log-charging) or
     (logfile = "pain" and log-pain) or
     (logfile = "tazs" and log-tazs) or
     (logfile = "trip" and log-trip) or
     (logfile = "charge-time" and log-charge-time) or
     (logfile = "seek-charger" and log-seek-charger) or
     (logfile = "seek-charger-result" and log-seek-charger-result) or
     (logfile = "need-to-charge" and log-need-to-charge) or
     (logfile = "trip-journey-timeuntildepart" and log-trip-journey-timeuntildepart) or
     (logfile = "break-up-trip" and log-break-up-trip) or
     (logfile = "break-up-trip-choice" and log-break-up-trip-choice) or
     (logfile = "available-chargers" and log-break-up-trip-choice) or     
     (logfile = "charge-limiting-factor" and log-charge-limiting-factor) or
     (logfile = "drivers" and log-drivers) or
     (logfile = "summary") or 
     (logfile = "driver-summary") or
     (logfile = "V2G-soc" and log-V2G-soc)
  [
    open-logfile logfile
    file-print reduce [(word ?1 "," ?2)] data-list
    file-flush
  ]
end

;;;;;;;;;;;;;;;;;;;;
;; OPEN LOGFILE
;;;;;;;;;;;;;;;;;;;;
to open-logfile [logfile]
  file-close
  file-open (word outputs-directory logfile "-out.csv" )
end

;;;;;;;;;;;;;;;;;;;;
;; RESET LOGFILE
;;;;;;;;;;;;;;;;;;;;
to reset-logfile [logfile]
  file-close
  if file-exists? (word outputs-directory logfile "-out.csv") [ file-delete (word outputs-directory logfile "-out.csv") ]
end

to log-driver [event-name]
  log-data "drivers" (sentence precision ticks 3 [id] of self event-name state-of-charge)
end
