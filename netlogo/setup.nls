;;;;;;;;;;;;;;;;;;;;;;;
;; READ PARAMETER FILE
;;;;;;;;;;;;;;;;;;;;;;;
to read-parameter-file
  ifelse (file-exists? parameter-file) [ 
    file-close
    file-open parameter-file
    while [not file-at-end?][
      let param-name file-read
      ifelse param-name = "n-nodes" [ set n-nodes file-read ][  ; TODO, infer this from the od input file
      ifelse param-name = "charge-safety-factor" [ set charge-safety-factor file-read ][
      ifelse param-name = "charger-search-distance" [ set charger-search-distance file-read ][
      ifelse param-name = "wait-time-mean" [ set wait-time-mean file-read ][
      ifelse param-name = "batt-cap-mean" [ set batt-cap-mean file-read ][
      ifelse param-name = "batt-cap-stdv" [ set batt-cap-stdv file-read ][
      ifelse param-name = "batt-cap-range" [set batt-cap-range file-read ][
      ifelse param-name = "fuel-economy-stdv" [ set fuel-economy-stdv file-read ][
      ifelse param-name = "fuel-economy-range" [ set fuel-economy-range file-read ][
      ifelse param-name = "charger-input-file" [ set charger-input-file file-read ][
      ifelse param-name = "driver-input-file" [ set driver-input-file file-read ][
      ifelse param-name = "od-input-file" [ set od-input-file file-read ][
      ]]]]]]]]]]]]
    ]
    file-close
  ][ 
    user-message (word "Input file '" od-input-file "' not found!") 
  ]
  
end

;;;;;;;;;;;;;;;;;;;;
;; SETUP OD DATA
;;;;;;;;;;;;;;;;;;;;
to setup-od-data
  print "setup-od-data"
  ; Reads in main driver input file: Origin, destination, # of trips, distance, time
  set od-from   n-values (n-nodes * n-nodes) [0] 
  set od-to     n-values (n-nodes * n-nodes) [0] 
  set od-dist   n-values (n-nodes * n-nodes) [0] 
  set od-time   n-values (n-nodes * n-nodes) [0] 
  set od-enroute n-values (n-nodes * n-nodes) [n-values (0) [0]] 
  
  ifelse (file-exists? od-input-file) [ ; ../inputs/OD_Matrix_5.txt
    file-close
    file-open od-input-file
    foreach n-values (n-nodes * n-nodes) [?] [
     set od-from   replace-item ? od-from file-read 
     set od-to     replace-item ? od-to   file-read 
     set od-dist   replace-item ? od-dist file-read 
     set od-time   replace-item ? od-time file-read
     set od-enroute replace-item ? od-enroute split file-read ","
    ]
    file-close
  ][ 
    user-message (word "Input file '" od-input-file "' not found!") 
  ]
end 

;;;;;;;;;;;;;;;;;;;;
;; SPLIT
;; Helper function written by jimlyons37: http://groups.yahoo.com/group/netlogo-users/message/6490
;; Adapted by Colin to allow empty string as argument and assumes elements are numbers, not strings
;;;;;;;;;;;;;;;;;;;;
to-report split [ #string #sep ] ; #sep must be non-empty string
  let result [] ; return value
  let w length #sep
  if length #string = 0 [ report result ]
  loop[ ; exit when done
    let next-pos position #sep #string
    if not is-number? next-pos [ report reverse (fput read-from-string #string result) ]
    set result fput read-from-string (substring #string 0 next-pos) result
    set #string substring #string (next-pos + w) (length #string)
  ]
end

;;;;;;;;;;;;;;;;;;;;
;; SETUP NODES
;;;;;;;;;;;;;;;;;;;;
to setup-nodes
  print "setup-nodes"
  create-nodes n-nodes
  ask nodes [
    set shape "star"
    set color yellow
    set size 0.5
    set n-levels n-values 3 [-99]
    set chargers-in-taz n-values 0 [0]
  ]
  ifelse (file-exists? charger-input-file) [ ; ../inputs/alternative_4_5.txt
    file-close
    file-open charger-input-file
    foreach sort nodes[ ;this block reads taz-id, location, and charger info into each node
      ask ? [
        set id file-read
        setxy file-read file-read
        foreach [0 1 2] [
          set n-levels replace-item ? n-levels file-read
        ]
        set neighbor-tazs n-values 0 [0]
        foreach n-values n-nodes [? + 1] [
          if not (? = id) and (distance-from-to id ? <= charger-search-distance) [
           set neighbor-tazs fput node ? neighbor-tazs
          ]
        ]
      ]    
    ]
  ]
  [ user-message (word "Input file '" charger-input-file "' not found!")]
   
end ;setup-nodes

;;;;;;;;;;;;;;;;;;;;;;;
;; CONVERT ENROUTE IDS
;;;;;;;;;;;;;;;;;;;;;;;
to convert-enroute-ids
  foreach n-values length od-enroute [?] [
    let old-enroute-list item ? od-enroute
    foreach n-values length old-enroute-list [?] [
      set old-enroute-list replace-item ? old-enroute-list (node item ? old-enroute-list)
    ]
    set od-enroute replace-item ? od-enroute old-enroute-list
  ]
end

;;;;;;;;;;;;;;;;;;;;
;; SETUP DRIVERS
;;;;;;;;;;;;;;;;;;;;
to setup-drivers
  print "setup-drivers"
  ; creating drivers based on GEATM data, in setup-itinerary procedure. 
  setup-itinerary
  ; initialize driver state variables
  ask drivers [
    set is-phev? false ; TODO needs to be determined during itinerary setup
    set current-itin-row -1
    update-itinerary
    set shape "car"
    set color green
    set size 2
    set time-opportunity-cost 12.5  ; $/kWh
    ifelse is-phev? [
      set battery-capacity 10 ; TODO replace with values from a vehicle type distribution input file
      set electric-fuel-consumption 0.35   ; kWh/mile
    ][ 
      set battery-capacity 25
      set electric-fuel-consumption 0.35
    ]
    set state-of-charge 1
    set willing-to-roam-time-threshold 0.2  ;; driver is willing to roam for 20 minutes. ac 9.28
    set state "not-charging"
    set current-charger nobody
    set journey-distance 0
    foreach n-values length itin-from [?] [
      set journey-distance (journey-distance + distance-from-to (item ? itin-from) (item ? itin-to) )
    ]
    set itin-complete? false
    itinerary-event-scheduler
  ]
end ;setup-drivers

;;;;;;;;;;;;;;;;;;;;
;; SETUP INTINERARY
;;;;;;;;;;;;;;;;;;;;
to setup-itinerary
  print "setup-itinerary"
  ifelse (file-exists? driver-input-file) [ ; ../inputs/p1r1_5.txt  
    file-close
    file-open driver-input-file
    let itin-row 0
    let this-itin true
    let next-driver file-read
    let this-driver 0
    while [file-at-end? = false] [
      set this-driver next-driver
      create-drivers 1 [
        set itin-from n-values 1 [file-read]     ; creates global itin-from
        set itin-to n-values 1 [file-read]       ; creates global itin-to
        set itin-depart n-values 1 [file-read]   ; creates global itin-depart
        if file-at-end? = false [
          set next-driver file-read
          set this-itin true
          while [next-driver = this-driver] [  
            set itin-from  lput file-read itin-from
            set itin-to  lput file-read itin-to
            set itin-depart lput file-read itin-depart
            ifelse file-at-end? [ set next-driver -1][ set next-driver file-read ]
          ] ; end while this-itin
        ]
      ] ; end create-drivers
    ] ; end while file-at-end
  ] ; end ifelse
  [ user-message (word "Input file '" driver-input-file "' not found!") ]
  file-close
end ;setup-itinerary

;;;;;;;;;;;;;;;;;;;;
;; SETUP CHARGERS
;;;;;;;;;;;;;;;;;;;;
to setup-chargers
  print "setup-chargers"
  ; The charger level, location, and quantity of chargers was read in during setup-nodes.
  ; Now chargers of each level are created at the appropriate node.
  ; Charger-rate is currently a separate state variable from charger level. We may want to combine the two later, if
  ; we do not use "charger level" for anything else.

  foreach sort nodes [                       ; At each node,  chargers equal to "taz-chargers"are created.
    create-chargers [item 0 n-levels] of ? [  ; The location of each charger created is then set as the current TAZ location
      set charger-type 1
      set charge-rate 2.4 ; Charger rate is the charger power in kW. Data from (Markel 2010), see project document
      set location ?
    ]
    create-chargers [item 0 n-levels] of ? [  ; The location of each charger created is then set as the current TAZ location
      set charger-type 2
      set charge-rate 19.2 ; Charger rate is the charger power in kW. Data from (Markel 2010), see project document
      set location ?
    ]
    create-chargers [item 0 n-levels] of ? [  ; The location of each charger created is then set as the current TAZ location
      set charger-type 3
      set charge-rate 30 ; Charger rate is the charger power in kW. Data from (Markel 2010), see project document
      set location ?
    ]
  ]  
  ask chargers [
    set shape "Circle 2"
    set color red
    set size 1
    set current-driver nobody
    set xcor [xcor] of location
    set ycor [ycor] of location
    ask location[
      set chargers-in-taz lput myself chargers-in-taz
    ]
  ]
end ;setup-chargers