;;;;;;;;;;;;;;;;;;;;;;;
;; READ PARAMETER FILE
;;;;;;;;;;;;;;;;;;;;;;;
to read-parameter-file
  ifelse (file-exists? parameter-file) [ 
    file-close
    file-open parameter-file
    while [not file-at-end?][
      let param-name file-read
      ifelse param-name = "n-tazs" [ set n-tazs file-read ][  ; TODO, infer this from the od input file
      ifelse param-name = "n-charger-types" [ set n-charger-types file-read ][  ; TODO, infer this from the od input file
      ifelse param-name = "charge-safety-factor" [ set charge-safety-factor file-read ][
      ifelse param-name = "charger-search-distance" [ set charger-search-distance file-read ][
      ifelse param-name = "wait-time-mean" [ set wait-time-mean file-read ][
      ifelse param-name = "batt-cap-mean" [ set batt-cap-mean file-read ][
      ifelse param-name = "batt-cap-stdv" [ set batt-cap-stdv file-read ][
      ifelse param-name = "batt-cap-range" [set batt-cap-range file-read ][
      ifelse param-name = "fuel-economy-stdv" [ set fuel-economy-stdv file-read ][
      ifelse param-name = "fuel-economy-range" [ set fuel-economy-range file-read ][
      ifelse param-name = "charger-input-file" [ set charger-input-file file-read ][
      ifelse param-name = "driver-input-file" [ set driver-input-file file-read ][
      ifelse param-name = "od-input-file" [ set od-input-file file-read ][
      ]]]]]]]]]]]]]
    ]
    file-close
  ][ 
    user-message (word "Input file '" od-input-file "' not found!") 
  ]
end

;;;;;;;;;;;;;;;;;;;;
;; SETUP OD DATA
;;;;;;;;;;;;;;;;;;;;
to setup-od-data
  print "setup-od-data"
  ; Reads in main driver input file: Origin, destination, # of trips, distance, time
  set od-from   n-values (n-tazs * n-tazs) [0] 
  set od-to     n-values (n-tazs * n-tazs) [0] 
  set od-dist   n-values (n-tazs * n-tazs) [0] 
  set od-time   n-values (n-tazs * n-tazs) [0] 
  set od-enroute n-values (n-tazs * n-tazs) [n-values (0) [0]] 
  
  ifelse (file-exists? od-input-file) [ ; ../inputs/OD_Matrix_5.txt
    file-close
    file-open od-input-file
    foreach n-values (n-tazs * n-tazs) [?] [
     set od-from   replace-item ? od-from file-read 
     set od-to     replace-item ? od-to   file-read 
     set od-dist   replace-item ? od-dist file-read 
     set od-time   replace-item ? od-time file-read
     set od-enroute replace-item ? od-enroute split file-read ","
    ]
    file-close
  ][ 
    user-message (word "Input file '" od-input-file "' not found!") 
  ]
end 

;;;;;;;;;;;;;;;;;;;;
;; SPLIT
;; Helper function written by jimlyons37: http://groups.yahoo.com/group/netlogo-users/message/6490
;; Adapted by Colin to allow empty string as argument and assumes elements are numbers, not strings
;;;;;;;;;;;;;;;;;;;;
to-report split [ #string #sep ] ; #sep must be non-empty string
  let result [] ; return value
  let w length #sep
  if length #string = 0 [ report result ]
  loop[ ; exit when done
    let next-pos position #sep #string
    if not is-number? next-pos [ report reverse (fput read-from-string #string result) ]
    set result fput read-from-string (substring #string 0 next-pos) result
    set #string substring #string (next-pos + w) (length #string)
  ]
end

;;;;;;;;;;;;;;;;;;;;
;; SETUP TAZS
;;;;;;;;;;;;;;;;;;;;
to setup-tazs
  print "setup-tazs"
  create-tazs n-tazs
  ask tazs [
    set shape "star"
    set color yellow
    set size 0.5
    set n-levels n-values 4 [-99]  ; 10.17 ac - 4 levels of chargers, 0,1,2,3, 0=home
    set chargers-by-type n-values n-charger-types [n-values 0 [0]]
  ]
  ifelse (file-exists? charger-input-file) [ ; ../inputs/alternative_4_5.txt
    file-close
    file-open charger-input-file
    foreach sort tazs [  ; we want the who value to match the id, so we sort them, this assumes the text file has sequential ids starting from 1
      ask ? [
        set id file-read
        foreach [0 1 2 3] [
          set n-levels replace-item ? n-levels file-read ; sets the number of level X chargers in each TAZ
        ]
        set neighbor-tazs n-values 0 [0]
        foreach n-values n-tazs [? + 1] [
          if not (? = id) and (distance-from-to id ? <= charger-search-distance) [
            set neighbor-tazs fput taz ? neighbor-tazs
          ]
        ]
      ]
    ]    
  ]
  [ user-message (word "Input file '" charger-input-file "' not found!")]
   
end ;setup-tazs

;;;;;;;;;;;;;;;;;;;;;;;
;; CONVERT ENROUTE IDS
;;;;;;;;;;;;;;;;;;;;;;;
to convert-enroute-ids
  foreach n-values length od-enroute [?] [
    let old-enroute-list item ? od-enroute
    foreach n-values length old-enroute-list [?] [
      set old-enroute-list replace-item ? old-enroute-list (taz item ? old-enroute-list)
    ]
    set od-enroute replace-item ? od-enroute old-enroute-list
  ]
end

;;;;;;;;;;;;;;;;;;;;
;; SETUP DRIVERS
;;;;;;;;;;;;;;;;;;;;
to setup-drivers
  print "setup-drivers"
  ; creating drivers based on GEATM data, in setup-itinerary procedure. 
  setup-itinerary
  ; initialize driver state variables
  ask drivers [
    set is-phev? false ; TODO needs to be determined during itinerary setup
    set current-itin-row -1
    update-itinerary
    set shape "car"
    set color green
    set size 2
    set time-opportunity-cost 12.5  ; $/kWh
    ifelse is-phev? [
      set battery-capacity 10 ; TODO replace with values from a vehicle type distribution input file
      set electric-fuel-consumption 0.35   ; kWh/mile
    ][ 
      set battery-capacity 25
      set electric-fuel-consumption 0.35
    ]
    set state-of-charge 1
    set willing-to-roam-time-threshold 0.2  ;; driver is willing to roam for 20 minutes. ac 9.28
    set state "not-charging"
    set current-charger nobody
    set journey-distance 0
    foreach n-values length itin-from [?] [
      set journey-distance (journey-distance + distance-from-to (item ? itin-from) (item ? itin-to) )
    ]
    set itin-complete? false
    itinerary-event-scheduler
  ]
end ;setup-drivers

;;;;;;;;;;;;;;;;;;;;
;; SETUP INTINERARY
;;;;;;;;;;;;;;;;;;;;
to setup-itinerary
  print "setup-itinerary"
  ifelse (file-exists? driver-input-file) [ ; ../inputs/p1r1_5.txt  
    file-close
    file-open driver-input-file
    let itin-row 0
    let this-itin true
    let next-driver file-read
    let this-driver 0
    while [file-at-end? = false] [
      set this-driver next-driver
      create-drivers 1 [
        set itin-from n-values 1 [file-read]     ; creates global itin-from
        set itin-to n-values 1 [file-read]       ; creates global itin-to
        set itin-depart n-values 1 [file-read]   ; creates global itin-depart
        if file-at-end? = false [
          set next-driver file-read
          set this-itin true
          while [next-driver = this-driver] [  
            set itin-from  lput file-read itin-from
            set itin-to  lput file-read itin-to
            set itin-depart lput file-read itin-depart
            ifelse file-at-end? [ set next-driver -1][ set next-driver file-read ]
          ] ; end while this-itin
        ]
      ] ; end create-drivers
    ] ; end while file-at-end
  ] ; end ifelse
  [ user-message (word "Input file '" driver-input-file "' not found!") ]
  file-close
end ;setup-itinerary

;;;;;;;;;;;;;;;;;;;;
;; SETUP CHARGER-TYPES
;;;;;;;;;;;;;;;;;;;;
to setup-charger-types
  print "setup-charger-types"
  
  create-charger-types 1 [
    set level 0          ; dedicated home charger
    set charge-rate 1.92 ; kW. 120V x 16A peak current, single phase: http://www.sae.org/mags/AEI/7479
    set energy-price 0.14 ; 
  ]
  create-charger-types 1 [  ; 
    set level 1
    set charge-rate 2.4 ; Charger rate is the charger power in kW. Data from (Markel 2010), see project document
    set energy-price 0.14 ; 
  ]
  create-charger-types 1 [  ; 
    set level 2
    set charge-rate 19.2 ; Charger rate is the charger power in kW. Data from (Markel 2010), see project document
    set energy-price 0.14 ; 
  ]
  create-charger-types 1 [  ; 
    set level 3
    set charge-rate 30 ; Charger rate is the charger power in kW. Data from (Markel 2010), see project document
                       ; Charger rate may be anywhere from 20-250kW (Markel 2010)
    set energy-price 0.14 ; 
  ]
end 

;;;;;;;;;;;;;;;;;;;;
;; SETUP CHARGERS
;;;;;;;;;;;;;;;;;;;;
to setup-chargers
  print "setup-chargers"
  ; The charger level, location, and quantity of chargers was read in during setup-tazs.
  ; Now chargers of each level are created at the appropriate taz.
  ; Charger-rate is currently a separate state variable from charger level. We may want to combine the two later, if
  ; we do not use "charger level" for anything else.

  ; At each taz,  chargers equal to "taz-chargers"are created.
  foreach sort tazs [
    create-chargers [item 0 n-levels] of ? [  ; The location of each charger created is then set as the current TAZ location
      set this-charger-type one-of charger-types with [level = 0]
      set location ?
    ]
    create-chargers [item 1 n-levels] of ? [  ; The location of each charger created is then set as the current TAZ location
      set this-charger-type one-of charger-types with [level = 1]
      set location ?
    ]
    create-chargers [item 2 n-levels] of ? [  ; The location of each charger created is then set as the current TAZ location
      set this-charger-type one-of charger-types with [level = 2]
      set location ?
    ]
    create-chargers [item 3 n-levels] of ? [  ; The location of each charger created is then set as the current TAZ location
      set this-charger-type one-of charger-types with [level = 3]
      set location ?
    ]
  ]  
  ask chargers [
    set shape "Circle 2"
    set color red
    set size 1
    set current-driver nobody
    ;set xcor [xcor] of location
    ;set ycor [ycor] of location
    let #level [level] of this-charger-type
    ask location[
      set chargers-by-type replace-item #level chargers-by-type lput myself item #level chargers-by-type
    ]
  ]
end ;setup-chargers